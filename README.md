# üè† EasySmart IoT Platform

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Node.js Version](https://img.shields.io/badge/node-%3E%3D18.19.0-brightgreen)](https://nodejs.org/)
[![PostgreSQL](https://img.shields.io/badge/PostgreSQL-16-blue)](https://www.postgresql.org/)
[![InfluxDB](https://img.shields.io/badge/InfluxDB-2.x-blue)](https://www.influxdata.com/)

> Plataforma SaaS multi-tenant para gerenciamento de dispositivos IoT usando ESP32/ESP8266 com ESPHome

**Status:** Phase 1.5 Complete ‚úÖ | **Version:** 0.2.0 | **Production Ready:** üü° MVP

---

## üìã √çndice

- [Vis√£o Geral](#-vis√£o-geral)
- [Arquitetura](#-arquitetura)
- [Stack Tecnol√≥gica](#-stack-tecnol√≥gica)
- [Funcionalidades Implementadas](#-funcionalidades-implementadas)
- [Instala√ß√£o](#-instala√ß√£o)
- [Configura√ß√£o](#-configura√ß√£o)
- [API Reference](#-api-reference)
- [MQTT Topics](#-mqtt-topics)
- [InfluxDB Schema](#-influxdb-schema)
- [Database Schema](#-database-schema)
- [Desenvolvimento](#-desenvolvimento)
- [Testes](#-testes)
- [Deploy](#-deploy)
- [LLM Collaboration Guide](#-llm-collaboration-guide)
- [Roadmap](#-roadmap)
- [Troubleshooting](#-troubleshooting)
- [Licen√ßa](#-licen√ßa)

---

## üéØ Vis√£o Geral

EasySmart √© uma plataforma IoT completa que permite:

- ‚úÖ **Gerenciamento Multi-Tenant** de dispositivos IoT
- ‚úÖ **Auto-Discovery via MQTT** (ESPHome native)
- ‚úÖ **Telemetria em tempo real** (MQTT ‚Üí InfluxDB)
- ‚úÖ **APIs REST** para integra√ß√£o com frontends
- ‚úÖ **Autentica√ß√£o JWT** (access + refresh tokens)
- ‚úÖ **Device Provisioning** com QR codes
- ‚úÖ **Queries time-series** com agrega√ß√µes

### Casos de Uso

- üè° Automa√ß√£o residencial
- üè≠ Monitoramento industrial
- üå°Ô∏è Sensoriamento ambiental
- üí° Controle de ilumina√ß√£o inteligente
- üîå Gerenciamento de energia

---

## üèóÔ∏è Arquitetura

### Diagrama de Componentes
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     FRONTEND (React)                         ‚îÇ
‚îÇ                    Port: 3000 (futuro)                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ HTTP/REST
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  BACKEND (Node.js/Express)                   ‚îÇ
‚îÇ                        Port: 3010                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ Auth/Users   ‚îÇ  ‚îÇ   Devices    ‚îÇ  ‚îÇ   Telemetry  ‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ             ‚îÇ             ‚îÇ                      ‚îÇ
    ‚îÇ PostgreSQL  ‚îÇ InfluxDB    ‚îÇ MQTT                 ‚îÇ
    ‚ñº             ‚ñº             ‚ñº                      ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇPostgreSQL‚îÇ  ‚îÇInfluxDB ‚îÇ  ‚îÇ Mosquitto‚îÇ         ‚îÇ ESPHome  ‚îÇ
‚îÇPort: 5432‚îÇ  ‚îÇPort:8086‚îÇ  ‚îÇPort: 1883‚îÇ         ‚îÇPort: 6052‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ MQTT Topics
                                ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   ESP32/ESP8266       ‚îÇ
                    ‚îÇ   (ESPHome Firmware)  ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Fluxo de Dados

#### 1. Discovery (Device ‚Üí Cloud)
```
ESP32 ‚Üí MQTT (easysmart/{device}/discovery) ‚Üí Backend
  ‚Üí PostgreSQL (devices, entities)
  ‚Üí Cache device_uuid
```

#### 2. Telemetria (Device ‚Üí Cloud)
```
ESP32 ‚Üí MQTT (.../{entity}/state) ‚Üí Backend
  ‚Üí Normalize payload (float/bool/string)
  ‚Üí Buffer (queue)
  ‚Üí Batch write (500ms ou 500 pontos)
  ‚Üí InfluxDB (telemetry measurement)
```

#### 3. Comandos (Cloud ‚Üí Device)
```
Frontend ‚Üí Backend API ‚Üí MQTT publish ‚Üí ESP32
```

---

## üõ†Ô∏è Stack Tecnol√≥gica

### Backend
- **Node.js** v18.19.1+ (LTS)
- **Express** 5.1.0 (Web framework)
- **PostgreSQL** 16 (Relational DB)
- **InfluxDB** 2.x (Time-series DB)
- **MQTT.js** 5.14.1 (MQTT client)
- **Pino** 9.5.0 (Structured logging)
- **Zod** 3.25.76 (Schema validation)
- **JWT** 9.0.2 (Authentication)
- **bcrypt** 5.1.1 (Password hashing)

### Infrastructure
- **Docker** & **Docker Compose**
- **Mosquitto** MQTT Broker
- **ESPHome** (Firmware framework)
- **Portainer** (Container management)

---

## ‚úÖ Funcionalidades Implementadas

### Phase 1.1 - Backend Base ‚úÖ
- [x] Express 5.1.0 com middlewares de seguran√ßa
- [x] Logging estruturado com Pino (pretty dev / JSON prod)
- [x] Conex√µes PostgreSQL, InfluxDB, MQTT
- [x] Health check endpoint
- [x] Graceful shutdown

### Phase 1.2 - Database & Auth ‚úÖ
- [x] Schema PostgreSQL (tenants, users, devices, entities)
- [x] Migrations com node-pg-migrate
- [x] JWT authentication (access + refresh tokens)
- [x] Multi-tenancy (row-level com tenant_id)
- [x] Password hashing (bcrypt)

### Phase 1.3 - Device Management ‚úÖ
- [x] CRUD de devices
- [x] Device provisioning (gerar tokens)
- [x] Device claiming (QR codes)
- [x] Entity management
- [x] Auto-discovery via MQTT

### Phase 1.4 - Device API REST ‚úÖ
- [x] `GET /api/v1/devices` - Lista devices
- [x] `GET /api/v1/devices/:id` - Detalhes
- [x] `GET /api/v1/devices/:id/entities` - Entities
- [x] `DELETE /api/v1/devices/:id` - Remove
- [x] MQTT discovery handler

### Phase 1.5 - Telemetry API ‚úÖ
- [x] MQTT listener para telemetria
- [x] Buffer + batch write no InfluxDB (500ms/500 pontos)
- [x] Retry com exponential backoff
- [x] Cache device_uuid (evita queries PostgreSQL)
- [x] Normaliza√ß√£o de payloads (float, bool, string)
- [x] Schema InfluxDB (measurement: telemetry)
- [x] API de leitura: latest, series, metrics
- [x] Valida√ß√£o Zod para queries

---

## üöÄ Instala√ß√£o

### Pr√©-requisitos

- Ubuntu 24.04 LTS (ou similar)
- Node.js >= 18.19.0
- Docker >= 20.10
- Docker Compose >= 2.0
- Git >= 2.30

### 1. Clone o reposit√≥rio
```bash
git clone https://github.com/rodrigo-s-lange/easysmart-platform.git
cd easysmart-platform
```

### 2. Infraestrutura (Docker)
```bash
cd ~/docker
cp .env.example .env

# Editar senhas se necess√°rio
nano .env

# Iniciar servi√ßos
docker compose up -d

# Verificar
docker compose ps
```

### 3. Backend
```bash
cd ~/easysmart-platform/backend

# Instalar depend√™ncias
npm install

# Criar .env
cp .env.example .env
nano .env  # Ajustar credenciais

# Criar database
docker exec -it postgres psql -U postgres -c "CREATE DATABASE easysmart;"

# Rodar migrations
npm run migrate:up

# Iniciar
npm run dev  # Desenvolvimento
npm start    # Produ√ß√£o
```

---

## üîß Configura√ß√£o

### Backend `.env`
```bash
# PostgreSQL
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_secure_password
POSTGRES_DB=easysmart
DATABASE_URL=postgresql://postgres:password@localhost:5432/easysmart

# InfluxDB
INFLUXDB_URL=http://localhost:8086
INFLUXDB_TOKEN=your_influxdb_token
INFLUXDB_ORG=easysmart
INFLUXDB_BUCKET=iot_data

# MQTT
MQTT_HOST=localhost
MQTT_PORT=1883
MQTT_USERNAME=devices
MQTT_PASSWORD=your_mqtt_password

# Server
PORT=3010
NODE_ENV=development
LOG_LEVEL=info

# JWT
JWT_SECRET=your_super_secret_jwt_key_min_32_chars
JWT_ACCESS_EXPIRATION=15m
JWT_REFRESH_EXPIRATION=7d

# Bcrypt
BCRYPT_ROUNDS=10
```

---

## üìö API Reference

### Base URL
```
http://localhost:3010/api/v1
```

### Authentication

#### `POST /auth/register`
Cria novo usu√°rio e tenant

**Request:**
```json
{
  "email": "user@example.com",
  "password": "senha123456",
  "name": "Nome do Usu√°rio"
}
```

**Response:** `201 Created`
```json
{
  "user": {
    "id": "uuid",
    "tenant_id": "uuid",
    "email": "user@example.com",
    "role": "admin"
  },
  "tokens": {
    "accessToken": "jwt_token",
    "refreshToken": "rt_token"
  }
}
```

#### `POST /auth/login`
Autentica usu√°rio

**Request:**
```json
{
  "email": "user@example.com",
  "password": "senha123456"
}
```

**Response:** `200 OK`
```json
{
  "user": { /* ... */ },
  "tokens": {
    "accessToken": "jwt_token",
    "refreshToken": "rt_token"
  }
}
```

#### `POST /auth/refresh`
Renova access token

**Request:**
```json
{
  "refreshToken": "rt_token"
}
```

**Response:** `200 OK`
```json
{
  "accessToken": "new_jwt_token"
}
```

---

### Devices

**Todas as rotas exigem autentica√ß√£o:** `Authorization: Bearer {token}`

#### `GET /devices`
Lista todos os devices do tenant

**Response:** `200 OK`
```json
[
  {
    "id": "uuid",
    "name": "ESP32 Living Room",
    "status": "online",
    "device_token": "easysmrt_dev_...",
    "last_seen": "2025-10-16T23:00:00.000Z",
    "metadata": {
      "mqtt_id": "esp32-lab",
      "model": "ESP32",
      "manufacturer": "Espressif"
    }
  }
]
```

#### `GET /devices/:id`
Detalhes de um device

**Response:** `200 OK`
```json
{
  "device": { /* ... */ },
  "entities": [
    {
      "id": "uuid",
      "entity_type": "sensor",
      "entity_id": "temperature",
      "name": "Temperature",
      "unit": "¬∞C",
      "device_class": "temperature"
    }
  ]
}
```

#### `POST /devices/provision`
Provisiona novo device (gera tokens)

**Request:**
```json
{
  "name": "ESP32 Kitchen",
  "template_id": null
}
```

**Response:** `201 Created`
```json
{
  "device": {
    "id": "uuid",
    "name": "ESP32 Kitchen",
    "device_token": "easysmrt_dev_...",
    "claim_token": "easysmrt_claim_...",
    "qr_code": "data:image/png;base64,..."
  }
}
```

#### `DELETE /devices/:id`
Remove device e suas entities

**Response:** `204 No Content`

---

### Telemetry

#### `GET /telemetry/:deviceId/latest/:entityId`
Retorna √∫ltimo valor de uma entidade

**Response:** `200 OK`
```json
{
  "success": true,
  "data": {
    "deviceUuid": "uuid",
    "entityId": "temperature",
    "entityType": "sensor",
    "value": 23.8,
    "field": "value_float",
    "unit": "¬∞C",
    "timestamp": "2025-10-16T23:02:42.6Z"
  }
}
```

#### `GET /telemetry/:deviceId/:entityId`
S√©rie temporal com agrega√ß√£o

**Query Params:**
- `start`: -6h (default), -24h, -7d
- `stop`: now() (default)
- `window`: 1m (default), 5m, 1h, 1d
- `aggregation`: mean (default), min, max, sum, count, first, last

**Response:** `200 OK`
```json
{
  "success": true,
  "count": 120,
  "params": {
    "deviceId": "uuid",
    "entityId": "temperature",
    "start": "-6h",
    "window": "1m",
    "aggregation": "mean"
  },
  "data": [
    {
      "timestamp": "2025-10-16T17:00:00.000Z",
      "value": 23.5,
      "field": "value_float"
    }
  ]
}
```

#### `GET /telemetry/metrics`
M√©tricas do Influx Writer

**Response:** `200 OK`
```json
{
  "success": true,
  "metrics": {
    "pointsWritten": 1523,
    "pointsDropped": 0,
    "writeErrors": 0,
    "lastWriteTime": "2025-10-16T23:03:38.678Z",
    "lastWriteStatus": "ok",
    "queueSize": 0,
    "cacheSize": 15
  }
}
```

---

## üì° MQTT Topics

### Estrutura de T√≥picos
```
easysmart/{DEVICE_ID}/{TYPE}/{ENTITY_ID}/{ACTION}
```

### Discovery

**Topic:** `easysmart/{device_id}/discovery`

**Payload:**
```json
{
  "device": {
    "id": "esp32-lab",
    "name": "Lab Sensor",
    "model": "ESP32",
    "manufacturer": "Espressif",
    "sw_version": "2024.1.0"
  },
  "entities": [
    {
      "type": "sensor",
      "id": "temperature",
      "name": "Temperature",
      "unit": "¬∞C",
      "device_class": "temperature"
    },
    {
      "type": "sensor",
      "id": "humidity",
      "name": "Humidity",
      "unit": "%",
      "device_class": "humidity"
    },
    {
      "type": "switch",
      "id": "relay1",
      "name": "Relay 1"
    }
  ]
}
```

### Telemetria (Device ‚Üí Cloud)

#### Sensores (Float)
**Topic:** `easysmart/{device_id}/sensor/{entity_id}/state`

**Payload:**
```json
{ "value": 23.5, "unit": "¬∞C" }
```

ou string pura:
```
23.5
```

#### Switches/Binary Sensors (Boolean)
**Topic:** `easysmart/{device_id}/switch/{entity_id}/state`

**Payload:**
```
ON
```
ou
```
OFF
```

ou JSON:
```json
{ "state": "ON" }
```

### Comandos (Cloud ‚Üí Device)

**Topic:** `easysmart/{device_id}/switch/{entity_id}/command`

**Payload:**
```
ON
```
ou
```
OFF
```

### Availability

**Topic:** `easysmart/{device_id}/availability`

**Payload:**
```
online
```
ou
```
offline
```

---

## üíæ InfluxDB Schema

### Bucket
- **Nome:** `iot_data`
- **Reten√ß√£o:** 90 dias (configur√°vel)

### Measurement
- **Nome:** `telemetry`

### Tags (Indexados)
```
tenant_id       UUID do tenant (futuro)
device_uuid     UUID do device (PostgreSQL)
mqtt_id         ID MQTT do device (ex: esp32-lab)
entity_id       ID da entidade (ex: temperature, relay1)
entity_type     Tipo (sensor, switch, binary_sensor)
device_class    Classe (temperature, humidity, power)
unit            Unidade (¬∞C, %, W, kWh)
```

### Fields (Valores)
```
value_float     Valores num√©ricos (float64)
value_bool      Valores booleanos (bool)
value_string    Valores string (string)
```

**Regra:** Apenas 1 field por ponto (evita conflito de tipos)

### Exemplo de Point
```javascript
{
  measurement: "telemetry",
  tags: {
    device_uuid: "6865e0bd-3f13-458a-9a3a-e833881cb0c2",
    mqtt_id: "esp32-lab",
    entity_id: "temperature",
    entity_type: "sensor",
    device_class: "temperature",
    unit: "¬∞C"
  },
  fields: {
    value_float: 23.5
  },
  timestamp: 1729094567000
}
```

### Query Examples (Flux)

#### √öltimo valor
```flux
from(bucket: "iot_data")
  |> range(start: -7d)
  |> filter(fn: (r) => r._measurement == "telemetry")
  |> filter(fn: (r) => r.device_uuid == "uuid")
  |> filter(fn: (r) => r.entity_id == "temperature")
  |> last()
```

#### S√©rie com agrega√ß√£o
```flux
from(bucket: "iot_data")
  |> range(start: -6h)
  |> filter(fn: (r) => r._measurement == "telemetry")
  |> filter(fn: (r) => r.device_uuid == "uuid")
  |> filter(fn: (r) => r.entity_id == "temperature")
  |> aggregateWindow(every: 1m, fn: mean, createEmpty: false)
```

---

## üóÑÔ∏è Database Schema

### Tables

#### `tenants`
```sql
CREATE TABLE tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### `users`
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  role TEXT DEFAULT 'user',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

#### `device_templates`
```sql
CREATE TABLE device_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  esphome_config JSONB,
  default_entities JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### `devices`
```sql
CREATE TABLE devices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  template_id UUID REFERENCES device_templates(id),
  name TEXT NOT NULL,
  device_token TEXT UNIQUE NOT NULL,
  claim_token TEXT UNIQUE,
  mac_address TEXT UNIQUE,
  status TEXT DEFAULT 'unclaimed',
  last_seen TIMESTAMP,
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  claimed_at TIMESTAMP,
  
  INDEX idx_devices_tenant (tenant_id),
  INDEX idx_devices_status (status)
);
```

#### `entities`
```sql
CREATE TABLE entities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  device_id UUID REFERENCES devices(id) ON DELETE CASCADE,
  entity_type TEXT NOT NULL,
  entity_id TEXT NOT NULL,
  name TEXT NOT NULL,
  unit TEXT,
  device_class TEXT,
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(device_id, entity_id),
  INDEX idx_entities_device (device_id)
);
```

#### `refresh_tokens`
```sql
CREATE TABLE refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT UNIQUE NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_refresh_tokens_user (user_id)
);
```

---

## üë®‚Äçüíª Desenvolvimento

### Estrutura de Pastas
```
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.js       # PostgreSQL pool
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ influxdb.js       # InfluxDB client (legacy)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.js         # Pino logger
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mqtt.js           # MQTT config (legacy)
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authController.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deviceController.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deviceApiController.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ telemetryController.js
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js           # JWT validation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errorHandler.js   # Global error handler
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ devices.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ telemetry.js
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ influxService.js  # InfluxDB writer (buffer + retry)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mqttService.js    # MQTT listener + publisher
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ token.js          # Token generation
‚îÇ   ‚îî‚îÄ‚îÄ server.js             # Entry point
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îî‚îÄ‚îÄ 1760638437331_create-initial-schema.js
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md
```

### Conventions

#### Git Commits (Conventional Commits)
```bash
feat: nova funcionalidade
fix: corre√ß√£o de bug
docs: documenta√ß√£o
refactor: refatora√ß√£o
test: testes
chore: manuten√ß√£o
perf: performance
```

#### Code Style
- Indenta√ß√£o: 2 espa√ßos
- Quotes: Single `'`
- Semicolons: Obrigat√≥rio
- Line length: 100 caracteres
- Naming:
  - `camelCase` para vari√°veis/fun√ß√µes
  - `PascalCase` para classes
  - `UPPER_CASE` para constantes

### Logging
```javascript
const logger = require('./config/logger');

logger.trace('trace');
logger.debug('debug');
logger.info('info');
logger.warn('warning');
logger.error({ err }, 'error');
logger.fatal({ err }, 'fatal');

// Structured
logger.info({ userId: 123, action: 'login' }, 'User logged in');
```

---

## üß™ Testes

### E2E Testing

#### 1. Health Check
```bash
curl http://localhost:3010/health | jq
```

#### 2. Authentication
```bash
# Register
curl -X POST http://localhost:3010/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"senha123","name":"Test User"}' | jq

# Login
TOKEN=$(curl -s -X POST http://localhost:3010/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"senha123"}' \
  | jq -r '.tokens.accessToken')
```

#### 3. MQTT Discovery
```bash
docker exec mosquitto mosquitto_pub \
  -h localhost -u devices -P 'your_mqtt_password' \
  -t 'easysmart/esp32-test/discovery' \
  -m '{
    "device": {"id":"esp32-test","name":"Test Device"},
    "entities": [
      {"type":"sensor","id":"temp","name":"Temperature","unit":"¬∞C"}
    ]
  }'
```

#### 4. MQTT Telemetry
```bash
# Float
docker exec mosquitto mosquitto_pub \
  -h localhost -u devices -P 'your_mqtt_password' \
  -t 'easysmart/esp32-test/sensor/temp/state' \
  -m '{"value": 24.5, "unit": "¬∞C"}'

# Boolean
docker exec mosquitto mosquitto_pub \
  -h localhost -u devices -P 'your_mqtt_password' \
  -t 'easysmart/esp32-test/switch/relay1/state' \
  -m 'ON'
```

#### 5. Query Telemetry
```bash
# Latest
curl -s "http://localhost:3010/api/v1/telemetry/{device_id}/latest/temp" \
  -H "Authorization: Bearer $TOKEN" | jq

# Series
curl -s "http://localhost:3010/api/v1/telemetry/{device_id}/temp?start=-1h&window=1m" \
  -H "Authorization: Bearer $TOKEN" | jq

# Metrics
curl -s "http://localhost:3010/api/v1/telemetry/metrics" \
  -H "Authorization: Bearer $TOKEN" | jq
```

---

## ü§ñ LLM Collaboration Guide

Este projeto foi desenvolvido colaborativamente entre humanos e LLMs (Claude, ChatGPT). Use este guia para dar continuidade ao desenvolvimento.

### Context for LLMs

#### Project Status (2025-10-16)
- **Phase:** 1.5 Complete ‚úÖ
- **Next:** Phase 2.1 - Frontend Base
- **Node Version:** 18.19.1
- **Location:** `~/easysmart-platform/backend`

#### Key Architecture Decisions

1. **Multi-tenancy:** Row-level com `tenant_id` em todas as tabelas
2. **Auth:** JWT (15min access + 7d refresh)
3. **Telemetry:** Buffer (500ms/500 pontos) ‚Üí Batch write InfluxDB
4. **MQTT:** Auto-discovery + telemetria em t√≥picos separados
5. **Schema InfluxDB:** 1 measurement (`telemetry`) + 3 fields (float/bool/string)

#### Known Issues & Solutions

**Issue:** Query series com erro "unsupported input type for mean aggregate: boolean"
**Cause:** Query pegando m√∫ltiplos fields (value_float + value_bool)
**Solution:** Filtrar apenas field desejado na query Flux:
```flux
|> filter(fn: (r) => r._field == "value_float")
```

**Issue:** Port 3001 vs 3010
**Solution:** Backend roda na porta **3010** (`.env: PORT=3010`)

**Issue:** Middleware `authenticateToken` not found
**Solution:** Nome correto √© `requireAuth` em `src/middleware/auth.js`

#### Important Files to Read

1. `README.md` - Este arquivo (documenta√ß√£o completa)
2. `backend/src/services/influxService.js` - Writer robusto com buffer
3. `backend/src/services/mqttService.js` - Listener telemetria + discovery
4. `backend/src/server.js` - Entry point
5. `migrations/1760638437331_create-initial-schema.js` - Schema DB

#### Commands Reference
```bash
# Start backend
cd ~/easysmart-platform/backend
npm run dev

# Database
docker exec -it postgres psql -U postgres easysmart

# Migrations
npm run migrate:up
npm run migrate:down
npm run migrate:create -- migration-name

# Logs
docker logs mosquitto --tail 50
docker logs influxdb --tail 50
docker logs postgres --tail 50

# Git
git status
git add .
git commit -m "type: message"
git push origin main
Environment Variables
bash# Get credentials
grep POSTGRES_PASSWORD ~/docker/.env
grep INFLUXDB_ADMIN_TOKEN ~/docker/.env
grep MQTT_PASSWORD ~/docker/.env
Testing Workflow

Start backend: npm run dev
Publish MQTT discovery
Publish MQTT telemetry
Query via API (need JWT token)
Check logs for errors

Next Steps Recommendations
Phase 2.1 - Frontend Base

Setup React + Vite + TypeScript
Login/Register pages
Dashboard layout
Device list component
Real-time telemetry charts (recharts or chart.js)

Phase 1.6 - Enhancements

Fix series query (filter by field type)
Add downsampling (1m, 1h buckets)
Implement rate limiting per device
Add WebSocket for real-time updates
Unit tests (Jest + Supertest)


üó∫Ô∏è Roadmap
‚úÖ Phase 1.1 - Backend Base (COMPLETE)

 Express setup
 PostgreSQL, InfluxDB, MQTT connections
 Logging (Pino)
 Health check

‚úÖ Phase 1.2 - Database & Auth (COMPLETE)

 Schema PostgreSQL
 Migrations
 JWT auth
 Multi-tenancy

‚úÖ Phase 1.3 - Device Management (COMPLETE)

 CRUD devices
 Device provisioning
 Auto-discovery

‚úÖ Phase 1.4 - Device API REST (COMPLETE)

 GET /devices
 GET /devices/:id
 DELETE /devices/:id

‚úÖ Phase 1.5 - Telemetry API (COMPLETE)

 MQTT listener telemetria
 Buffer + batch write InfluxDB
 Cache device_uuid
 APIs: latest, series, metrics
 Validation (Zod)

üîÑ Phase 1.6 - Enhancements (NEXT)

 Fix series query (filter by field)
 Downsampling (InfluxDB tasks)
 Rate limiting per device
 WebSocket real-time
 Unit tests

üìã Phase 2.1 - Frontend Base

 Setup React + Vite + TypeScript
 Authentication pages
 Dashboard layout
 Device list
 Real-time charts

üìã Phase 2.2 - ESPHome Integration

 ESPHome config generator
 Firmware OTA updates
 Device templates UI
 WiFi provisioning

üöÄ Phase 3.1 - Production Ready

 Docker multi-stage builds
 CI/CD (GitHub Actions)
 Monitoring (Prometheus + Grafana)
 Backup automation
 API documentation (Swagger)

üåü Phase 3.2 - Advanced Features

 Webhooks
 Home Assistant integration
 Mobile app (React Native)
 Rules engine (automations)
 Marketplace


üêõ Troubleshooting
Backend n√£o inicia
bash# Verificar logs
cd ~/easysmart-platform/backend
npm run dev

# Verificar portas
netstat -tulpn | grep -E '3010|5432|8086|1883'

# Verificar Docker
cd ~/docker
docker compose ps
Database "easysmart" does not exist
bashdocker exec -it postgres psql -U postgres -c "CREATE DATABASE easysmart;"
MQTT n√£o conecta
bash# Logs
docker logs mosquitto --tail 50

# Testar
docker exec mosquitto mosquitto_pub \
  -h localhost -u devices -P 'senha' \
  -t 'test' -m 'hello'

# Verificar credenciais
grep MQTT_PASSWORD ~/docker/.env
InfluxDB n√£o conecta
bash# Logs
docker logs influxdb --tail 50

# Verificar token
docker exec influxdb influx auth list

# Testar
curl -I http://localhost:8086/health
Telemetria n√£o aparece no InfluxDB
bash# 1. Verificar logs do backend (telemetria enfileirada?)
# 2. Verificar m√©tricas do writer
curl -s "http://localhost:3010/api/v1/telemetry/metrics" \
  -H "Authorization: Bearer $TOKEN" | jq

# 3. Query direto no InfluxDB
docker exec influxdb influx query \
  'from(bucket:"iot_data") |> range(start:-1h) |> filter(fn:(r) => r._measurement == "telemetry")'
Query series retorna erro "unsupported input type"
Causa: Query pegando m√∫ltiplos field types (float + bool)
Solu√ß√£o: Filtrar field espec√≠fico:
bash# Para sensores num√©ricos, adicionar na query:
?start=-1h&field=value_float

# Implementar no c√≥digo (pendente Phase 1.6)
Port 3001 vs 3010
Backend roda na porta 3010 por padr√£o. Verificar .env:
bashgrep PORT backend/.env
# Deve mostrar: PORT=3010
Limpar e reconstruir
bash# CUIDADO: Apaga dados!
cd ~/docker
docker compose down -v
docker compose up -d

# Recriar banco
docker exec -it postgres psql -U postgres -c "CREATE DATABASE easysmart;"

# Rodar migrations
cd ~/easysmart-platform/backend
npm run migrate:up

# Reiniciar
npm run dev

üìä M√©tricas e Monitoramento
Health Check
bashcurl http://localhost:3010/health | jq
Response:
json{
  "status": "ok",
  "services": {
    "postgres": true,
    "influxdb": true,
    "mqtt": true
  },
  "influxWriter": {
    "pointsWritten": 1523,
    "pointsDropped": 0,
    "writeErrors": 0,
    "queueSize": 0,
    "cacheSize": 15
  }
}
Logs Estruturados (Pino)
Development: Pretty-printed colorido
Production: JSON (parse com tools como ELK, Grafana Loki)
bash# Ver logs em tempo real
cd ~/easysmart-platform/backend
npm run dev

# Filtrar por n√≠vel
npm run dev 2>&1 | grep ERROR
```

---

## üìÑ Licen√ßa

Este projeto est√° licenciado sob a licen√ßa MIT - veja o arquivo [LICENSE](LICENSE) para detalhes.

---

## üë• Autor

**Rodrigo S. Lange**
- GitHub: [@rodrigo-s-lange](https://github.com/rodrigo-s-lange)
- Email: rodrigo@easysmart.io

---

## üôè Agradecimentos

### Tecnologias
- [ESPHome](https://esphome.io/) - Framework ESP32/ESP8266
- [Express.js](https://expressjs.com/) - Web framework Node.js
- [InfluxDB](https://www.influxdata.com/) - Time-series database
- [Eclipse Mosquitto](https://mosquitto.org/) - MQTT broker
- [Pino](https://getpino.io/) - Fast logger

### AI Collaboration
Este projeto foi desenvolvido em colabora√ß√£o entre:
- **Humano:** Rodrigo S. Lange (arquitetura, decis√µes, testes)
- **Claude (Anthropic):** Implementa√ß√£o Phase 1.1-1.5
- **ChatGPT (OpenAI):** Revis√µes e melhorias

O trabalho conjunto entre LLMs est√° acelerando o desenvolvimento de software de forma incr√≠vel! üöÄ

---

**Last Updated:** 2025-10-16  
**Version:** 0.2.0  
**Status:** Phase 1.5 Complete ‚úÖ  
**Production Ready:** üü° MVP Ready

---

## üìû Suporte

- **Issues:** [GitHub Issues](https://github.com/rodrigo-s-lange/easysmart-platform/issues)
- **Discussions:** [GitHub Discussions](https://github.com/rodrigo-s-lange/easysmart-platform/discussions)
- **Email:** rodrigo@easysmart.io

---

**Built with ‚ù§Ô∏è by humans and AI working together**